<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gallery | Michael Qiu</title>
    <link rel="shortcut icon" type="image/png" href="resources/favicon.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            darkMode: 'class', 
            theme: {
                extend: {
                    colors: {
                        'klein-blue': '#002FA7',
                        'bg-dark': '#050505',
                        'bg-light': '#F2F2F7', 
                        'deep-navy': '#020412',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                        display: ['Syncopate', 'sans-serif'],
                        serif: ['Playfair Display', 'serif'],
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-out forwards',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 6s ease-in-out infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        },
                        float: {
                            '0%, 100%': { transform: 'translateY(0px)' },
                            '50%': { transform: 'translateY(-20px)' },
                        }
                    }
                }
            }
        }
    </script>
    
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Flip.min.js"></script>
    
    <!-- Draggable -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;900&family=JetBrains+Mono:wght@400;700&family=Syncopate:wght@700;800&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <style>
        :root {
            --klein-blue: #002FA7;
            --electron-radius: 400;
        }

        body {
            background-color: #050505;
            color: #ffffff;
            transition: background 0.8s cubic-bezier(0.16, 1, 0.3, 1);
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            margin: 0;
        }

        html.dark body {
            background-color: #050505;
            color: #ffffff;
        }

        .glass-card { 
            background: rgba(20, 20, 20, 0.3); 
            backdrop-filter: blur(20px); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); 
            will-change: transform, box-shadow;
        }

        .nav-glass {
            background: rgba(150, 150, 150, 0.1); 
            backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .gallery-container {
            width: 300vw;
            height: 300vh;
            position: relative;
            transform-origin: 0 0;
            will-change: transform;
            cursor: grab;
        }

        .gallery-container:active {
            cursor: grabbing;
        }

        .photo-electron {
            position: absolute;
            width: 200px;
            height: 300px;
            /* Transition removed for active state to allow GSAP full control */
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            z-index: 10;
            will-change: transform, left, top;
        }

        .photo-electron:hover {
            z-index: 100;
            transform: scale(1.05);
        }

        /* Removed .active and .expanded fixed positioning to let GSAP handle the transition to the specific grid cell */

        .electron-orbital {
            position: absolute;
            border: 1px dashed rgba(0, 47, 167, 0.3);
            border-radius: 50%;
            pointer-events: none;
        }

        .photo-frame {
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            background: #000;
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .photo-electron:hover .photo-frame {
            box-shadow: 0 30px 80px rgba(0, 47, 167, 0.4);
            border-color: var(--klein-blue);
        }

        .photo-electron:hover img {
            transform: scale(1.05);
        }

        .detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            height: 90vh;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            display: grid;
            grid-template-columns: 1fr 1fr;
            overflow: hidden;
            box-shadow: 0 50px 100px rgba(0, 0, 0, 0.8);
        }

        .detail-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Mobile Responsive for Detail Panel */
        @media (max-width: 768px) {
            .detail-panel {
                grid-template-columns: 1fr;
                grid-template-rows: 40% 60%;
            }
        }

        .detail-photo {
            position: relative;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 20px;
        }

        /* This image is the final static one, we might hide it until animation ends */
        .detail-photo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0; /* Hidden initially, revealed after FLIP */
            transition: opacity 0.3s ease;
        }
        .detail-photo img.visible {
            opacity: 1;
        }

        .detail-content {
            padding: 60px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        @media (max-width: 768px) {
            .detail-content { padding: 30px; }
        }

        .detail-content h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 20px;
            color: white;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .meta-item {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .meta-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--klein-blue);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .meta-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
        }

        .diary-content {
            font-family: 'Playfair Display', serif;
            font-size: 1.4rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
            font-style: italic;
            flex-grow: 1;
        }

        .close-button {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .close-button:hover {
            background: var(--klein-blue);
            transform: rotate(90deg);
        }

        .mode-switcher {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .mode-button {
            padding: 12px 24px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            color: white;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-button.active {
            background: var(--klein-blue);
            border-color: var(--klein-blue);
        }

        .mode-button:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
        }

        .back-button {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 100;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: var(--klein-blue);
            transform: translateX(-5px);
        }

        .nav-info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            z-index: 100;
        }

        .canvas-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050505;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--klein-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'JetBrains Mono', monospace;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Loading Screen -->
        <div class="loading-screen" v-if="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">LOADING GALLERY...</div>
        </div>

        <!-- Navigation -->
        <div class="back-button" @click="goBack">
            <i data-lucide="arrow-left" class="w-6 h-6"></i>
        </div>

        <div class="mode-switcher">
            <button class="mode-button active" @click="switchMode('random')">
                <i data-lucide="atom" class="w-4 h-4 inline mr-2"></i> RANDOM
            </button>
            <button class="mode-button" @click="switchMode('timeline')">
                <i data-lucide="calendar" class="w-4 h-4 inline mr-2"></i> TIMELINE
            </button>
        </div>

        <div class="nav-info">
            DRAG TO MOVE • CLICK TO VIEW • ESC TO EXIT
        </div>

        <!-- Main Gallery Container -->
        <div class="gallery-container" 
             ref="galleryContainer"
             :style="{ transform: `translate(${-offset.x}px, ${-offset.y}px)` }">
             
            <!-- Orbital Rings -->
            <div v-for="(ring, index) in orbitals" 
                 :key="'ring-'+index" 
                 class="electron-orbital"
                 :style="{
                     width: ring.radius * 2 + 'px',
                     height: ring.radius * 2 + 'px',
                     left: ring.centerX + 'px',
                     top: ring.centerY + 'px',
                     transform: `translate(-50%, -50%)`
                 }">
            </div>

            <!-- Photo Electrons -->
            <div v-for="photo in photos" 
                 :key="photo.id"
                 :id="'photo-electron-' + photo.id"
                 class="photo-electron"
                 :class="{ 'active': activePhoto === photo.id }"
                 :style="{
                     left: photo.position.x + 'px',
                     top: photo.position.y + 'px',
                 }"
                 @click="selectPhoto(photo)">
                <div class="photo-frame">
                    <img :src="photo.url" :alt="photo.title" loading="lazy" />
                </div>
            </div>
        </div>

        <!-- Detail Panel -->
        <div class="detail-panel" :class="{ 'active': expandedPhoto }">
            <div class="close-button" @click="closeDetailPanel">
                <i data-lucide="x" class="w-6 h-6"></i>
            </div>
            
            <!-- Target container for the image -->
            <div class="detail-photo" ref="detailPhotoContainer">
                <!-- The image here is only for layout/final state -->
                <img v-if="selectedPhoto" 
                     :src="selectedPhoto.url" 
                     :alt="selectedPhoto.title" 
                     :class="{ 'visible': isDetailImageVisible }" />
            </div>
            
            <div class="detail-content" v-if="selectedPhoto">
                <h1>{{ selectedPhoto.title }}</h1>
                
                <div class="meta-grid">
                    <div class="meta-item">
                        <div class="meta-label">Location</div>
                        <div class="meta-value">{{ selectedPhoto.location }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Date</div>
                        <div class="meta-value">{{ selectedPhoto.date }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Camera</div>
                        <div class="meta-value">{{ selectedPhoto.camera || 'iPhone 15 Pro' }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Aperture</div>
                        <div class="meta-value">{{ selectedPhoto.aperture || 'f/1.8' }}</div>
                    </div>
                </div>

                <div class="diary-content">
                    {{ selectedPhoto.diary }}
                </div>

                <div class="mt-8 pt-8 border-t border-white/10">
                    <div class="flex gap-4">
                        <span v-for="tag in selectedPhoto.tags" :key="tag"
                              class="px-3 py-1 bg-white/5 rounded-full text-sm font-mono text-white/60">
                            #{{ tag }}
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Background -->
        <canvas class="canvas-bg" ref="bgCanvas"></canvas>
    </div>

    <script>
        const { createApp, ref, onMounted, onUnmounted, nextTick } = Vue;
        gsap.registerPlugin(Flip);

        createApp({
            setup() {
                // State
                const mode = ref('random');
                const photos = ref([]);
                const orbitals = ref([]);
                // Initial offset centers the view on the 300vw/300vh container
                // Container Center is (1.5w, 1.5h). Viewport is (0.5w, 0.5h).
                // Offset = 1.0w, 1.0h
                const offset = ref({ x: 0, y: 0 }); 
                
                const activePhoto = ref(null);
                const expandedPhoto = ref(null);
                const selectedPhoto = ref(null);
                const isDetailImageVisible = ref(false);
                const loading = ref(true);
                
                // Refs
                const galleryContainer = ref(null);
                const bgCanvas = ref(null);
                const detailPhotoContainer = ref(null);
                
                // Physics
                const center = ref({ x: 0, y: 0 }); // Will be set on mount
                const orbitalConfig = [
                    { radius: 400, electronCount: 4, speed: 0.002 },
                    { radius: 600, electronCount: 5, speed: 0.0015 },
                    { radius: 800, electronCount: 6, speed: 0.001 },
                    { radius: 1000, electronCount: 7, speed: 0.0008 }
                ];

                // Load photos from JSON
                const loadPhotos = async () => {
                    try {
                        const response = await fetch('https://raw.githubusercontent.com/gitmichaelqiu/gitmichaelqiu.github.io/refs/heads/main/photos.json');
                        const data = await response.json();
                        photos.value = data.photos;
                        initializeRandomPositions();
                        loading.value = false;
                    } catch (error) {
                        console.error('Error loading photos:', error);
                        loading.value = false;
                        // Mock data fallback if fetch fails
                        if(photos.value.length === 0) {
                            photos.value = Array.from({length: 10}, (_, i) => ({
                                id: i,
                                url: `https://picsum.photos/seed/${i}/400/600`,
                                title: 'Sample Photo ' + i,
                                location: 'Unknown',
                                date: '2025',
                                diary: 'Sample description...'
                            }));
                            initializeRandomPositions();
                        }
                    }
                };

                // Initialize random positions
                const initializeRandomPositions = () => {
                    // Update center based on current window size
                    center.value = { x: window.innerWidth * 1.5, y: window.innerHeight * 1.5 };

                    // Create orbitals
                    orbitals.value = orbitalConfig.map((config, index) => ({
                        ...config,
                        centerX: center.value.x + (Math.random() - 0.5) * 800,
                        centerY: center.value.y + (Math.random() - 0.5) * 800,
                        currentAngle: Math.random() * Math.PI * 2
                    }));

                    // Distribute photos across orbitals
                    photos.value.forEach((photo, index) => {
                        const orbitalIndex = index % orbitalConfig.length;
                        const orbital = orbitals.value[orbitalIndex];
                        const electronIndex = Math.floor(index / orbitalConfig.length);
                        const totalInOrbital = Math.ceil(photos.value.length / orbitalConfig.length);
                        const angle = (2 * Math.PI / totalInOrbital) * electronIndex;
                        
                        const jitter = 0.25;
                        const baseX = orbital.centerX + Math.cos(angle) * orbital.radius;
                        const baseY = orbital.centerY + Math.sin(angle) * orbital.radius;
                        
                        photo.position = {
                            x: baseX + (Math.random() - 0.5) * orbital.radius * jitter,
                            y: baseY + (Math.random() - 0.5) * orbital.radius * jitter,
                            orbital: orbitalIndex,
                            angle: angle,
                            baseRadius: orbital.radius,
                            baseX: orbital.centerX,
                            baseY: orbital.centerY
                        };
                    });
                };

                // Update electron positions
                const updateElectronPositions = () => {
                    if (loading.value) return;
                    
                    orbitals.value.forEach((orbital, orbitalIndex) => {
                        orbital.currentAngle += orbital.speed;
                        
                        // Update photos in this orbital
                        photos.value.forEach(photo => {
                            // Only animate if NOT the active one
                            if (photo.position.orbital === orbitalIndex && activePhoto.value !== photo.id) {
                                const newAngle = photo.position.angle + orbital.currentAngle;
                                const waveFactor = 0.95 + Math.sin(Date.now() * 0.001 + photo.id) * 0.1;
                                
                                photo.position.x = orbital.centerX + Math.cos(newAngle) * photo.position.baseRadius * waveFactor;
                                photo.position.y = orbital.centerY + Math.sin(newAngle) * photo.position.baseRadius * waveFactor;
                            }
                        });
                    });
                };

                // Select photo with GSAP FLIP-like Logic
                const selectPhoto = async (photo) => {
                    if (expandedPhoto.value === photo.id) return;
                    
                    // 1. Lock the system
                    activePhoto.value = photo.id;
                    selectedPhoto.value = photo;
                    isDetailImageVisible.value = false;
                    
                    // 2. Animate other photos away slightly
                    photos.value.forEach(p => {
                        if (p.id !== photo.id) {
                            // Calculate vector away from the selected photo
                            const dx = p.position.x - photo.position.x;
                            const dy = p.position.y - photo.position.y;
                            const angle = Math.atan2(dy, dx);
                            // Push away
                            gsap.to(`#photo-electron-${p.id}`, {
                                x: Math.cos(angle) * 200, // Relative push
                                y: Math.sin(angle) * 200,
                                opacity: 0.2,
                                scale: 0.8,
                                duration: 1,
                                ease: "power2.out"
                            });
                        }
                    });

                    await nextTick();

                    // 3. Get Coordinates
                    const el = document.getElementById(`photo-electron-${photo.id}`);
                    const targetContainer = detailPhotoContainer.value; // The .detail-photo div

                    if (el && targetContainer) {
                        // Calculate where the detail image fits
                        const targetRect = targetContainer.getBoundingClientRect();
                        const startRect = el.getBoundingClientRect();

                        // Fit logic: contain (preserve aspect ratio)
                        // But here we can just expand the card to fill the target container area
                        // The container has padding 20px, so we target the inner content area or the whole container
                        // Let's target the container for the "fly in" effect
                        
                        // We need to calculate global offset because `el` is inside a transformed container
                        // To solve this simply: flip `el` to `fixed` position at its current screen coords first.
                        
                        // Get current screen coordinates
                        const screenX = startRect.left;
                        const screenY = startRect.top;
                        const screenW = startRect.width;
                        const screenH = startRect.height;

                        // Force fixed position immediately via inline styles to break out of container transform
                        gsap.set(el, {
                            position: 'fixed',
                            left: screenX,
                            top: screenY,
                            width: screenW,
                            height: screenH,
                            zIndex: 9999,
                            transform: 'none', // Remove any scale/translate from container inheritance if any (though position fixed helps)
                            margin: 0
                        });

                        // 4. Animate to Target
                        // We want to center the image in the left panel.
                        // The detail photo container is the left panel cell.
                        // Let's make the card fill that space minus padding.
                        const pad = 40; // visual padding
                        const destW = Math.min(targetRect.width - pad, targetRect.height * (screenW/screenH)); // maintain aspect roughly or just fill
                        // Actually, let's just fly to the center of the target cell
                        
                        // Simple approach: Fly to the target rect
                        gsap.to(el, {
                            left: targetRect.left + 20, // + padding
                            top: targetRect.top + 20,
                            width: targetRect.width - 40,
                            height: targetRect.height - 40,
                            rotation: 0,
                            duration: 0.8,
                            ease: "power4.inOut",
                            onComplete: () => {
                                expandedPhoto.value = photo.id;
                                isDetailImageVisible.value = true;
                                // Hide the flying element effectively (it's covered by the new DOM, or we can fade it out)
                                gsap.to(el, { opacity: 0, duration: 0.2 });
                            }
                        });
                    }
                };

                // Close detail panel
                const closeDetailPanel = () => {
                    const photo = selectedPhoto.value;
                    expandedPhoto.value = null;
                    isDetailImageVisible.value = false;
                    
                    const el = document.getElementById(`photo-electron-${photo.id}`);
                    
                    if (el) {
                        // 1. Reset the flying element to visible
                        gsap.set(el, { opacity: 1 });
                        
                        // 2. Calculate where it should go back to (World Coordinates)
                        // We need to translate World Coords -> Screen Coords based on current offset
                        const worldX = photo.position.x;
                        const worldY = photo.position.y;
                        const screenDestX = worldX - offset.value.x;
                        const screenDestY = worldY - offset.value.y;

                        // 3. Animate back
                        gsap.to(el, {
                            left: screenDestX,
                            top: screenDestY,
                            width: 200, // Original width
                            height: 300, // Original height
                            duration: 0.8,
                            ease: "power4.inOut",
                            onComplete: () => {
                                // Revert to absolute positioning inside container
                                gsap.set(el, {
                                    position: 'absolute',
                                    left: worldX,
                                    top: worldY,
                                    zIndex: 10,
                                    transform: 'none' // clear transforms
                                });
                                activePhoto.value = null;
                                selectedPhoto.value = null;
                            }
                        });
                    }

                    // Reset others
                    photos.value.forEach(p => {
                        if (p.id !== photo.id) {
                            gsap.to(`#photo-electron-${p.id}`, {
                                x: 0,
                                y: 0,
                                opacity: 1,
                                scale: 1,
                                duration: 0.8,
                                delay: 0.2
                            });
                        }
                    });
                };

                // Switch mode
                const switchMode = (newMode) => {
                    mode.value = newMode;
                    if (newMode === 'random') {
                        // initializeRandomPositions(); // Don't reset completely, maybe just re-arrange? 
                        // For now keep simple
                    }
                };

                // Go back
                const goBack = () => {
                    window.location.href = 'index.html';
                };

                // Initialize background canvas
                const initBackgroundCanvas = () => {
                    const canvas = bgCanvas.value;
                    if(!canvas) return;
                    const ctx = canvas.getContext('2d');
                    
                    const resizeCanvas = () => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                    
                    resizeCanvas();
                    window.addEventListener('resize', resizeCanvas);
                    
                    // Draw electron field
                    const drawField = () => {
                        if (loading.value) {
                            requestAnimationFrame(drawField);
                            return;
                        }
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw faint orbital lines
                        ctx.strokeStyle = 'rgba(0, 47, 167, 0.1)';
                        ctx.lineWidth = 1;
                        
                        orbitals.value.forEach(orbital => {
                            ctx.beginPath();
                            ctx.arc(
                                orbital.centerX - offset.value.x,
                                orbital.centerY - offset.value.y,
                                orbital.radius,
                                0,
                                Math.PI * 2
                            );
                            ctx.stroke();
                        });
                        
                        // Draw connection lines between nearby photos
                        ctx.strokeStyle = 'rgba(0, 47, 167, 0.05)';
                        ctx.lineWidth = 0.5;
                        
                        for (let i = 0; i < photos.value.length; i++) {
                            for (let j = i + 1; j < photos.value.length; j++) {
                                const p1 = photos.value[i];
                                const p2 = photos.value[j];
                                
                                // Optimization: Only check logic if vaguely close
                                if (Math.abs(p1.position.orbital - p2.position.orbital) > 1) continue;

                                const dx = p1.position.x - p2.position.x;
                                const dy = p1.position.y - p2.position.y;
                                const distSq = dx * dx + dy * dy;
                                
                                if (distSq < 160000) { // 400^2
                                    ctx.beginPath();
                                    ctx.moveTo(p1.position.x - offset.value.x, p1.position.y - offset.value.y);
                                    ctx.lineTo(p2.position.x - offset.value.x, p2.position.y - offset.value.y);
                                    ctx.stroke();
                                }
                            }
                        }
                        
                        requestAnimationFrame(drawField);
                    };
                    
                    drawField();
                    
                    return () => {
                        window.removeEventListener('resize', resizeCanvas);
                    };
                };

                // Initialize drag
                const initDrag = () => {
                    // We use GSAP Draggable for smoother experience on the container
                    Draggable.create(galleryContainer.value, {
                        type: "x,y",
                        inertia: true,
                        edgeResistance: 0.65,
                        onDrag: function() {
                            // Update our reactive offset based on Draggable's result
                            // Draggable changes the transform string directly.
                            // We need to sync our state so the canvas draws correctly.
                            offset.value.x = -this.x;
                            offset.value.y = -this.y;
                        },
                        onThrowUpdate: function() {
                            offset.value.x = -this.x;
                            offset.value.y = -this.y;
                        },
                        // Set initial bounds or start position
                        // Note: GSAP Draggable works on the element's transform.
                        // Our manual start was via :style. Draggable picks that up.
                    });
                };

                // Animation loop
                const animationLoop = () => {
                    updateElectronPositions();
                    requestAnimationFrame(animationLoop);
                };

                onMounted(async () => {
                    // Set initial offset to center the universe in the viewport
                    offset.value.x = window.innerWidth;
                    offset.value.y = window.innerHeight;

                    // Initialize
                    lucide.createIcons();
                    await loadPhotos();
                    
                    // Initialize GSAP Draggable logic instead of manual events
                    // Need to wait for DOM update with offset style
                    await nextTick();
                    
                    // Manually set initial transform for GSAP to pick up correct starting values
                    gsap.set(galleryContainer.value, { x: -offset.value.x, y: -offset.value.y });
                    
                    initDrag();
                    const cleanup = initBackgroundCanvas();
                    animationLoop();
                    
                    // Click outside to close detail panel
                    document.addEventListener('click', (e) => {
                        if (expandedPhoto.value && !e.target.closest('.detail-panel') && 
                            !e.target.closest('.photo-electron') && !e.target.closest('.close-button')) {
                            closeDetailPanel();
                        }
                    });
                    
                    return cleanup;
                });

                onUnmounted(() => {
                    // Cleanup
                    window.removeEventListener('resize', () => {});
                });

                return {
                    mode,
                    photos,
                    orbitals,
                    offset,
                    activePhoto,
                    expandedPhoto,
                    selectedPhoto,
                    loading,
                    galleryContainer,
                    bgCanvas,
                    detailPhotoContainer,
                    isDetailImageVisible,
                    selectPhoto,
                    closeDetailPanel,
                    switchMode,
                    goBack
                };
            }
        }).mount('#app');
    </script>
</body>
</html>