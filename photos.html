<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gallery | Michael Qiu</title>
    <link rel="shortcut icon" type="image/png" href="resources/favicon.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            darkMode: 'class', 
            theme: {
                extend: {
                    colors: {
                        'klein-blue': '#002FA7',
                        'bg-dark': '#050505',
                        'bg-light': '#F2F2F7', 
                        'deep-navy': '#020412',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                        display: ['Syncopate', 'sans-serif'],
                        serif: ['Playfair Display', 'serif'],
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-out forwards',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 6s ease-in-out infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        },
                        float: {
                            '0%, 100%': { transform: 'translateY(0px)' },
                            '50%': { transform: 'translateY(-20px)' },
                        }
                    }
                }
            }
        }
    </script>
    
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Flip.min.js"></script>
    
    <!-- Draggable -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;900&family=JetBrains+Mono:wght@400;700&family=Syncopate:wght@700;800&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <style>
        :root {
            --klein-blue: #002FA7;
            --electron-radius: 400;
        }

        body {
            background-color: #050505;
            color: #ffffff;
            transition: background 0.8s cubic-bezier(0.16, 1, 0.3, 1);
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            user-select: none;
        }

        html.dark body {
            background-color: #050505;
            color: #ffffff;
        }

        .glass-card { 
            background: rgba(20, 20, 20, 0.3); 
            backdrop-filter: blur(20px); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1); 
            will-change: transform, box-shadow;
        }

        /* --- GALLERY LAYOUT --- */
        .gallery-viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }
        .gallery-viewport:active {
            cursor: grabbing;
        }

        .gallery-mover {
            /* This div is moved by Draggable (X/Y) */
            width: 300vw;
            height: 300vh;
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
        }

        .gallery-scaler {
            /* This div is scaled by Vue (Zoom) */
            width: 100%;
            height: 100%;
            transform-origin: center center; /* Zoom from center relative to the mover */
            will-change: transform;
            transition: transform 0.1s linear; /* Smooth zoom */
        }

        .photo-electron {
            position: absolute;
            width: 200px;
            height: 300px;
            /* No transition on transform to avoid fighting the physics loop */
            transition: box-shadow 0.3s ease;
            z-index: 10;
            will-change: transform, left, top;
        }

        .photo-electron:hover {
            z-index: 100;
            transform: scale(1.05); /* Local hover effect */
        }
        
        /* When active, we hide the original because the clone takes over */
        .photo-electron.is-hidden {
            opacity: 0 !important;
            pointer-events: none;
        }

        .electron-orbital {
            position: absolute;
            border: 1px dashed rgba(0, 47, 167, 0.3);
            border-radius: 50%;
            pointer-events: none;
        }

        .photo-frame {
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            background: #000;
            position: relative;
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .photo-electron:hover .photo-frame {
            box-shadow: 0 30px 80px rgba(0, 47, 167, 0.4);
            border-color: var(--klein-blue);
        }

        /* --- CLONE ANIMATION LAYER --- */
        #clone-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        
        .animation-clone {
            position: fixed;
            transform-origin: top left;
            box-shadow: 0 30px 80px rgba(0, 47, 167, 0.5);
            border-radius: 12px;
            overflow: hidden;
            z-index: 9999;
        }
        .animation-clone img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* --- DETAIL PANEL --- */
        .detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            height: 90vh;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            display: grid;
            grid-template-columns: 1fr 1fr;
            overflow: hidden;
            box-shadow: 0 50px 100px rgba(0, 0, 0, 0.8);
        }

        .detail-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        @media (max-width: 768px) {
            .detail-panel {
                grid-template-columns: 1fr;
                grid-template-rows: 40% 60%;
            }
        }

        .detail-photo {
            position: relative;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 20px;
        }

        .detail-photo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0; 
            transition: opacity 0.3s ease;
        }
        .detail-photo img.visible {
            opacity: 1;
        }

        .detail-content {
            padding: 60px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        @media (max-width: 768px) {
            .detail-content { padding: 30px; }
        }

        .detail-content h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 20px;
            color: white;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .meta-item {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .meta-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--klein-blue);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .meta-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
        }

        .diary-content {
            font-family: 'Playfair Display', serif;
            font-size: 1.4rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
            font-style: italic;
            flex-grow: 1;
        }

        .close-button {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .close-button:hover {
            background: var(--klein-blue);
            transform: rotate(90deg);
        }

        .mode-switcher {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .mode-button {
            padding: 12px 24px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            color: white;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-button.active {
            background: var(--klein-blue);
            border-color: var(--klein-blue);
        }

        .back-button {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 100;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: var(--klein-blue);
            transform: translateX(-5px);
        }

        .nav-info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            z-index: 100;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .canvas-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050505;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--klein-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'JetBrains Mono', monospace;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Loading Screen -->
        <div class="loading-screen" v-if="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">LOADING GALLERY...</div>
        </div>

        <!-- UI Overlays -->
        <div class="back-button" @click="goBack">
            <i data-lucide="arrow-left" class="w-6 h-6"></i>
        </div>

        <div class="mode-switcher">
            <button class="mode-button active" @click="switchMode('random')">
                <i data-lucide="atom" class="w-4 h-4 inline mr-2"></i> RANDOM
            </button>
            <button class="mode-button" @click="switchMode('timeline')">
                <i data-lucide="calendar" class="w-4 h-4 inline mr-2"></i> TIMELINE
            </button>
        </div>

        <div class="nav-info">
            <span>DRAG TO MOVE</span>
            <span class="opacity-30">|</span>
            <span>SCROLL TO ZOOM</span>
            <span class="opacity-30">|</span>
            <span>CLICK TO VIEW</span>
        </div>

        <!-- Main Gallery Container -->
        <div class="gallery-viewport" ref="galleryViewport" @wheel="handleWheel">
            <div class="gallery-mover" ref="galleryMover">
                <div class="gallery-scaler" :style="{ transform: `scale(${scale})` }">
                    <!-- Orbital Rings -->
                    <div v-for="(ring, index) in orbitals" 
                         :key="'ring-'+index" 
                         class="electron-orbital"
                         :style="{
                             width: ring.radius * 2 + 'px',
                             height: ring.radius * 2 + 'px',
                             left: ring.centerX + 'px',
                             top: ring.centerY + 'px',
                             transform: `translate(-50%, -50%)`
                         }">
                    </div>

                    <!-- Photo Electrons -->
                    <div v-for="photo in photos" 
                         :key="photo.id"
                         :id="'photo-electron-' + photo.id"
                         class="photo-electron"
                         :class="{ 'is-hidden': activePhoto === photo.id }"
                         :style="{
                             left: photo.position.x + 'px',
                             top: photo.position.y + 'px',
                         }"
                         @click="selectPhoto(photo)">
                        <div class="photo-frame">
                            <img :src="photo.url" :alt="photo.title" loading="lazy" />
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Clone Container for Animation -->
        <div id="clone-container"></div>

        <!-- Detail Panel -->
        <div class="detail-panel" :class="{ 'active': expandedPhoto }">
            <div class="close-button" @click="closeDetailPanel">
                <i data-lucide="x" class="w-6 h-6"></i>
            </div>
            
            <div class="detail-photo" ref="detailPhotoContainer">
                <img v-if="selectedPhoto" 
                     :src="selectedPhoto.url" 
                     :alt="selectedPhoto.title" 
                     :class="{ 'visible': isDetailImageVisible }" />
            </div>
            
            <div class="detail-content" v-if="selectedPhoto">
                <h1>{{ selectedPhoto.title }}</h1>
                
                <div class="meta-grid">
                    <div class="meta-item">
                        <div class="meta-label">Location</div>
                        <div class="meta-value">{{ selectedPhoto.location }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Date</div>
                        <div class="meta-value">{{ selectedPhoto.date }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Camera</div>
                        <div class="meta-value">{{ selectedPhoto.camera || 'iPhone 15 Pro' }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Aperture</div>
                        <div class="meta-value">{{ selectedPhoto.aperture || 'f/1.8' }}</div>
                    </div>
                </div>

                <div class="diary-content">
                    {{ selectedPhoto.diary }}
                </div>

                <div class="mt-8 pt-8 border-t border-white/10">
                    <div class="flex gap-4">
                        <span v-for="tag in selectedPhoto.tags" :key="tag"
                              class="px-3 py-1 bg-white/5 rounded-full text-sm font-mono text-white/60">
                            #{{ tag }}
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Background -->
        <canvas class="canvas-bg" ref="bgCanvas"></canvas>
    </div>

    <script>
        const { createApp, ref, onMounted, onUnmounted, nextTick } = Vue;

        createApp({
            setup() {
                // State
                const mode = ref('random');
                const photos = ref([]);
                const orbitals = ref([]);
                
                // Camera State
                const offset = ref({ x: 0, y: 0 }); 
                const scale = ref(1.0);
                
                // Interaction State
                const activePhoto = ref(null);
                const expandedPhoto = ref(null);
                const selectedPhoto = ref(null);
                const isDetailImageVisible = ref(false);
                const loading = ref(true);
                const dragInstance = ref(null);
                
                // Refs
                const galleryViewport = ref(null);
                const galleryMover = ref(null);
                const bgCanvas = ref(null);
                const detailPhotoContainer = ref(null);
                
                // Config
                const center = ref({ x: 0, y: 0 }); 
                const orbitalConfig = [
                    { radius: 400, electronCount: 4, speed: 0.002 },
                    { radius: 600, electronCount: 5, speed: 0.0015 },
                    { radius: 800, electronCount: 6, speed: 0.001 },
                    { radius: 1000, electronCount: 7, speed: 0.0008 }
                ];

                const loadPhotos = async () => {
                    try {
                        const response = await fetch('https://raw.githubusercontent.com/gitmichaelqiu/gitmichaelqiu.github.io/refs/heads/main/photos.json');
                        const data = await response.json();
                        photos.value = data.photos;
                        initializeRandomPositions();
                        loading.value = false;
                    } catch (error) {
                        console.error('Error loading photos:', error);
                        loading.value = false;
                        if(photos.value.length === 0) {
                            photos.value = Array.from({length: 10}, (_, i) => ({
                                id: i,
                                url: `https://picsum.photos/seed/${i}/400/600`,
                                title: 'Sample Photo ' + i,
                                location: 'Unknown',
                                date: '2025',
                                diary: 'Sample description...',
                                tags: ['sample', 'art']
                            }));
                            initializeRandomPositions();
                        }
                    }
                };

                const initializeRandomPositions = () => {
                    center.value = { x: window.innerWidth * 1.5, y: window.innerHeight * 1.5 };
                    orbitals.value = orbitalConfig.map((config, index) => ({
                        ...config,
                        centerX: center.value.x + (Math.random() - 0.5) * 800,
                        centerY: center.value.y + (Math.random() - 0.5) * 800,
                        currentAngle: Math.random() * Math.PI * 2
                    }));

                    photos.value.forEach((photo, index) => {
                        const orbitalIndex = index % orbitalConfig.length;
                        const orbital = orbitals.value[orbitalIndex];
                        const electronIndex = Math.floor(index / orbitalConfig.length);
                        const totalInOrbital = Math.ceil(photos.value.length / orbitalConfig.length);
                        const angle = (2 * Math.PI / totalInOrbital) * electronIndex;
                        const jitter = 0.25;
                        const baseX = orbital.centerX + Math.cos(angle) * orbital.radius;
                        const baseY = orbital.centerY + Math.sin(angle) * orbital.radius;
                        
                        photo.position = {
                            x: baseX + (Math.random() - 0.5) * orbital.radius * jitter,
                            y: baseY + (Math.random() - 0.5) * orbital.radius * jitter,
                            orbital: orbitalIndex,
                            angle: angle,
                            baseRadius: orbital.radius,
                            baseX: orbital.centerX,
                            baseY: orbital.centerY
                        };
                    });
                };

                const updateElectronPositions = () => {
                    if (loading.value || activePhoto.value) return; // Pause physics when viewing
                    
                    orbitals.value.forEach((orbital, orbitalIndex) => {
                        orbital.currentAngle += orbital.speed;
                        photos.value.forEach(photo => {
                            if (photo.position.orbital === orbitalIndex) {
                                const newAngle = photo.position.angle + orbital.currentAngle;
                                const waveFactor = 0.95 + Math.sin(Date.now() * 0.001 + photo.id) * 0.1;
                                photo.position.x = orbital.centerX + Math.cos(newAngle) * photo.position.baseRadius * waveFactor;
                                photo.position.y = orbital.centerY + Math.sin(newAngle) * photo.position.baseRadius * waveFactor;
                            }
                        });
                    });
                };

                // --- ZOOM LOGIC ---
                const handleWheel = (e) => {
                    if (expandedPhoto.value) return; // Disable zoom when detail is open
                    e.preventDefault();
                    
                    const zoomSensitivity = 0.001;
                    const delta = -e.deltaY * zoomSensitivity;
                    const newScale = Math.min(Math.max(0.1, scale.value + delta), 2.0);
                    
                    // Optional: Zoom towards mouse cursor could go here, 
                    // but simple center zoom is cleaner for this layout.
                    scale.value = newScale;
                };

                // --- ANIMATION LOGIC (CLONE STRATEGY) ---
                const selectPhoto = async (photo) => {
                    if (expandedPhoto.value === photo.id || activePhoto.value) return;
                    
                    // 1. Lock state
                    activePhoto.value = photo.id;
                    selectedPhoto.value = photo;
                    isDetailImageVisible.value = false;
                    if(dragInstance.value) dragInstance.value.disable(); // Disable drag

                    await nextTick();

                    // 2. Create Clone
                    const originalEl = document.getElementById(`photo-electron-${photo.id}`);
                    if (!originalEl) return;

                    const rect = originalEl.getBoundingClientRect();
                    const clone = document.createElement('div');
                    clone.id = 'active-clone';
                    clone.className = 'animation-clone';
                    clone.style.left = rect.left + 'px';
                    clone.style.top = rect.top + 'px';
                    clone.style.width = rect.width + 'px';
                    clone.style.height = rect.height + 'px';
                    
                    // Copy Image
                    const img = document.createElement('img');
                    img.src = photo.url;
                    clone.appendChild(img);
                    
                    document.getElementById('clone-container').appendChild(clone);

                    // 3. Calculate Target
                    const targetContainer = detailPhotoContainer.value;
                    const targetRect = targetContainer.getBoundingClientRect();
                    
                    // Simple fit logic for target dimension (keeping aspect ratio of card roughly or simply filling target area)
                    // We'll fill the target area minus some padding
                    const pad = 0; 
                    
                    // 4. Animate Clone
                    gsap.to(clone, {
                        left: targetRect.left + pad,
                        top: targetRect.top + pad,
                        width: targetRect.width - (pad*2),
                        height: targetRect.height - (pad*2),
                        duration: 0.8,
                        ease: "power4.inOut",
                        onComplete: () => {
                            expandedPhoto.value = photo.id;
                            isDetailImageVisible.value = true;
                            gsap.set(clone, { opacity: 0 }); // Hide clone, show real detail image
                        }
                    });

                    // 5. Push others away
                    photos.value.forEach(p => {
                        if (p.id !== photo.id) {
                            // Simple opacity fade out for cleaner focus
                            gsap.to(`#photo-electron-${p.id}`, { opacity: 0.1, duration: 0.5 });
                        }
                    });
                };

                const closeDetailPanel = () => {
                    const photo = selectedPhoto.value;
                    expandedPhoto.value = null;
                    isDetailImageVisible.value = false;
                    
                    const clone = document.getElementById('active-clone');
                    const originalEl = document.getElementById(`photo-electron-${photo.id}`);

                    if (clone && originalEl) {
                        // 1. Show clone again
                        gsap.set(clone, { opacity: 1 });
                        
                        // 2. Get current position of the hidden original element
                        // Since physics was paused, it should be where we left it.
                        // However, we need its SCREEN coordinates.
                        const rect = originalEl.getBoundingClientRect();

                        // 3. Animate back
                        gsap.to(clone, {
                            left: rect.left,
                            top: rect.top,
                            width: rect.width,
                            height: rect.height,
                            duration: 0.8,
                            ease: "power4.inOut",
                            onComplete: () => {
                                clone.remove();
                                activePhoto.value = null;
                                selectedPhoto.value = null;
                                if(dragInstance.value) dragInstance.value.enable();
                            }
                        });
                    }

                    // Restore others
                    photos.value.forEach(p => {
                        if (p.id !== photo.id) {
                            gsap.to(`#photo-electron-${p.id}`, { opacity: 1, duration: 0.5 });
                        }
                    });
                };

                const switchMode = (newMode) => {
                    mode.value = newMode;
                };

                const goBack = () => {
                    window.location.href = 'index.html';
                };

                // --- BACKGROUND CANVAS ---
                const initBackgroundCanvas = () => {
                    const canvas = bgCanvas.value;
                    if(!canvas) return;
                    const ctx = canvas.getContext('2d');
                    
                    const resizeCanvas = () => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                    
                    resizeCanvas();
                    window.addEventListener('resize', resizeCanvas);
                    
                    const drawField = () => {
                        if (loading.value) { requestAnimationFrame(drawField); return; }
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Apply Camera Transform to Context
                        ctx.save();
                        // 1. Translate to center of screen (optional, but good for zooming from center)
                        // Actually, we are applying transform to the DOM elements: translate(-offset) scale(scale)
                        // We must match that here.
                        
                        // The DOM structure: Mover (Translate) -> Scaler (Scale) -> Elements (Position)
                        // So a point P(x,y) in world space becomes:
                        // ScreenX = (P.x * scale) + (MoverX)
                        // Wait, Mover is outside Scaler.
                        // ScreenX = (P.x * scale) + MoverX ?? No.
                        // Structure: viewport -> mover -> scaler -> element
                        // Element is at x,y inside scaler.
                        // Scaler applies scale.
                        // Mover applies translate(-offset.x, -offset.y).
                        // So ScreenX = (x * scale) - offset.x ? No, translate is on parent.
                        // Transforms multiply. 
                        // Matrix: Translate(-off.x, -off.y) * Scale(s) * Point(x,y)
                        // Actually, translate is on outer div, scale on inner.
                        // So visually: The scaler origin is 0,0 of mover.
                        // Mover is at -off.x, -off.y relative to viewport.
                        // Scaler center is 50% 50% of mover? No, transform-origin is center.
                        // Let's simplify: Scaler is width 100%, height 100% of Mover (300vw/300vh).
                        // Mover is 300vw/300vh.
                        // Transform origin center means it scales from the center of the universe (1.5w, 1.5h).
                        
                        // To match canvas drawing:
                        // We need to transform the context similarly.
                        
                        // The Mover translation
                        ctx.translate(-offset.value.x, -offset.value.y);
                        
                        // The Scaler scaling
                        // We need to scale around the center of the mover div.
                        const universeW = window.innerWidth * 3; // 300vw approx (initial calc)
                        const universeH = window.innerHeight * 3;
                        const centerX = center.value.x; // This was initialized as window * 1.5
                        const centerY = center.value.y;
                        
                        ctx.translate(centerX, centerY);
                        ctx.scale(scale.value, scale.value);
                        ctx.translate(-centerX, -centerY);
                        
                        // Draw Orbitals
                        ctx.strokeStyle = 'rgba(0, 47, 167, 0.1)';
                        ctx.lineWidth = 1 / scale.value; // Keep lines thin
                        orbitals.value.forEach(orbital => {
                            ctx.beginPath();
                            ctx.arc(orbital.centerX, orbital.centerY, orbital.radius, 0, Math.PI * 2);
                            ctx.stroke();
                        });

                        // Draw Connections
                        ctx.strokeStyle = 'rgba(0, 47, 167, 0.05)';
                        ctx.lineWidth = 0.5 / scale.value;
                        
                        // Simple proximity check optimization
                        // Only draw connections if not zoomed out too far (optimization)
                        if (scale.value > 0.2) {
                            for (let i = 0; i < photos.value.length; i++) {
                                for (let j = i + 1; j < photos.value.length; j++) {
                                    const p1 = photos.value[i];
                                    const p2 = photos.value[j];
                                    if (Math.abs(p1.position.orbital - p2.position.orbital) > 1) continue;
                                    const dx = p1.position.x - p2.position.x;
                                    const dy = p1.position.y - p2.position.y;
                                    if (dx*dx + dy*dy < 160000) {
                                        ctx.beginPath();
                                        ctx.moveTo(p1.position.x, p1.position.y);
                                        ctx.lineTo(p2.position.x, p2.position.y);
                                        ctx.stroke();
                                    }
                                }
                            }
                        }

                        ctx.restore();
                        requestAnimationFrame(drawField);
                    };
                    
                    drawField();
                    return () => window.removeEventListener('resize', resizeCanvas);
                };

                // --- DRAGGABLE ---
                const initDrag = () => {
                    const el = galleryMover.value;
                    // Initial centering
                    offset.value.x = window.innerWidth;
                    offset.value.y = window.innerHeight;
                    gsap.set(el, { x: -offset.value.x, y: -offset.value.y });

                    dragInstance.value = Draggable.create(el, {
                        type: "x,y",
                        inertia: true,
                        edgeResistance: 0.65,
                        onDrag: function() {
                            offset.value.x = -this.x;
                            offset.value.y = -this.y;
                        },
                        onThrowUpdate: function() {
                            offset.value.x = -this.x;
                            offset.value.y = -this.y;
                        }
                    })[0];
                };

                const animationLoop = () => {
                    updateElectronPositions();
                    requestAnimationFrame(animationLoop);
                };

                onMounted(async () => {
                    lucide.createIcons();
                    await loadPhotos();
                    await nextTick();
                    initDrag();
                    const cleanup = initBackgroundCanvas();
                    animationLoop();
                    
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && expandedPhoto.value) {
                            closeDetailPanel();
                        }
                    });
                    
                    return cleanup;
                });

                return {
                    mode, photos, orbitals, scale, activePhoto, expandedPhoto, selectedPhoto, loading,
                    galleryViewport, galleryMover, bgCanvas, detailPhotoContainer, isDetailImageVisible,
                    selectPhoto, closeDetailPanel, switchMode, goBack, handleWheel
                };
            }
        }).mount('#app');
    </script>
</body>
</html>