<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gallery | Michael Qiu</title>
    <link rel="shortcut icon" type="image/png" href="resources/favicon.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            darkMode: 'class', 
            theme: {
                extend: {
                    colors: {
                        'klein-blue': '#002FA7',
                        'bg-dark': '#050505',
                        'bg-light': '#F2F2F7', 
                        'deep-navy': '#020412',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                        display: ['Syncopate', 'sans-serif'],
                        serif: ['Playfair Display', 'serif'],
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-out forwards',
                        'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        }
                    }
                }
            }
        }
    </script>
    
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;900&family=JetBrains+Mono:wght@400;700&family=Syncopate:wght@700;800&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <style>
        :root {
            --klein-blue: #002FA7;
        }

        body {
            background-color: #050505;
            color: #ffffff;
            transition: background 0.8s cubic-bezier(0.16, 1, 0.3, 1);
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            user-select: none;
        }

        /* --- GALLERY LAYOUT --- */
        .gallery-viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            touch-action: none;
        }
        .gallery-viewport:active {
            cursor: grabbing;
        }

        .gallery-mover {
            /* Handled exclusively by GSAP Draggable. No CSS transitions on transform! */
            width: 300vw;
            height: 300vh;
            position: absolute;
            top: 0;
            left: 0;
            will-change: transform;
        }

        .gallery-scaler {
            /* Handled exclusively by GSAP. No CSS transitions on transform! */
            width: 100%;
            height: 100%;
            transform-origin: 0 0; 
            will-change: transform;
        }

        /* --- PHOTO ITEMS --- */
        .photo-electron {
            position: absolute;
            width: 200px;
            height: 300px;
            transition: box-shadow 0.3s ease, opacity 0.3s ease;
            z-index: 10;
            will-change: transform, left, top;
        }

        .photo-electron:hover {
            z-index: 100;
            transform: scale(1.05);
        }
        
        .photo-electron.is-hidden {
            opacity: 0 !important;
            pointer-events: none;
        }

        .electron-orbital {
            position: absolute;
            border: 1px dashed rgba(0, 47, 167, 0.3);
            border-radius: 50%;
            pointer-events: none;
        }

        .photo-frame {
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            background: #000;
            position: relative;
        }

        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            pointer-events: none;
        }

        .photo-electron:hover .photo-frame {
            box-shadow: 0 30px 80px rgba(0, 47, 167, 0.4);
            border-color: var(--klein-blue);
        }

        /* --- CLONE ANIMATION LAYER --- */
        #clone-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        
        .animation-clone {
            position: fixed;
            transform-origin: top left;
            box-shadow: 0 50px 100px rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            overflow: hidden;
            z-index: 9999;
            will-change: transform, width, height, top, left;
            background: #000;
        }
        
        /* The image inside the clone - IMPORTANT: Start as cover, end as cover (but container matches ratio) */
        .detail-img {
            width: 100%;
            height: 100%;
            object-fit: cover; 
            display: block;
        }

        /* --- DETAIL PANEL --- */
        .detail-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            height: 90vh;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            display: grid;
            grid-template-columns: 1fr 1fr;
            overflow: hidden;
            box-shadow: 0 50px 100px rgba(0, 0, 0, 0.8);
        }

        .detail-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        @media (max-width: 768px) {
            .detail-panel {
                grid-template-columns: 1fr;
                grid-template-rows: 40% 60%;
            }
        }

        .detail-photo {
            position: relative;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 20px;
            /* Ensure the image container is above other panel elements if needed, 
               but usually content is on the right */
            z-index: 2002; 
        }

        /* The image inside detail-photo is injected via JS */
        .detail-photo img {
            border-radius: 4px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            width: 100%;
            height: 100%;
            object-fit: cover; /* Maintain cover since container is sized to ratio */
        }

        .detail-content {
            padding: 60px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            position: relative;
            z-index: 2002;
        }
        @media (max-width: 768px) {
            .detail-content { padding: 30px; }
        }

        .detail-content h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 900;
            line-height: 1.1;
            margin-bottom: 20px;
            color: white;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 40px;
        }

        .meta-item {
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .meta-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--klein-blue);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .meta-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
        }

        .diary-content {
            font-family: 'Playfair Display', serif;
            font-size: 1.4rem;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
            font-style: italic;
            flex-grow: 1;
        }

        .close-button {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 2005; /* Above everything */
        }

        .close-button:hover {
            background: var(--klein-blue);
            transform: rotate(90deg);
        }

        .mode-switcher {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .mode-button {
            padding: 12px 24px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            color: white;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-button.active {
            background: var(--klein-blue);
            border-color: var(--klein-blue);
        }

        .back-button {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 100;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: var(--klein-blue);
            transform: translateX(-5px);
        }

        .nav-info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            z-index: 100;
            display: flex;
            gap: 12px;
            align-items: center;
            pointer-events: none;
        }

        .canvas-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050505;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--klein-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'JetBrains Mono', monospace;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Loading Screen -->
        <div class="loading-screen" v-if="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text">LOADING GALLERY...</div>
        </div>

        <!-- UI Overlays -->
        <div class="back-button" @click="goBack">
            <i data-lucide="arrow-left" class="w-6 h-6"></i>
        </div>

        <div class="mode-switcher">
            <button class="mode-button active" @click="switchMode('random')">
                <i data-lucide="atom" class="w-4 h-4 inline mr-2"></i> RANDOM
            </button>
            <button class="mode-button" @click="switchMode('timeline')">
                <i data-lucide="calendar" class="w-4 h-4 inline mr-2"></i> TIMELINE
            </button>
        </div>

        <div class="nav-info">
            <span>DRAG TO MOVE</span>
            <span class="opacity-30">|</span>
            <span>SCROLL TO ZOOM</span>
            <span class="opacity-30">|</span>
            <span>CLICK TO VIEW</span>
        </div>

        <!-- Main Gallery Container -->
        <div class="gallery-viewport" ref="galleryViewport" @wheel="handleWheel">
            <!-- GSAP handles transform directly. No Vue binding for style to avoid conflicts. -->
            <div class="gallery-mover" ref="galleryMover">
                <!-- GSAP handles scale directly via handleWheel logic -->
                <div class="gallery-scaler" ref="galleryScaler">
                    <!-- Orbital Rings -->
                    <div v-for="(ring, index) in orbitals" 
                         :key="'ring-'+index" 
                         class="electron-orbital"
                         :style="{
                             width: ring.radius * 2 + 'px',
                             height: ring.radius * 2 + 'px',
                             left: ring.centerX + 'px',
                             top: ring.centerY + 'px',
                             transform: `translate(-50%, -50%)`
                         }">
                    </div>

                    <!-- Photo Electrons -->
                    <div v-for="photo in photos" 
                         :key="photo.id"
                         :id="'photo-electron-' + photo.id"
                         class="photo-electron"
                         :class="{ 'is-hidden': activePhoto === photo.id }"
                         :style="{
                             left: photo.position.x + 'px',
                             top: photo.position.y + 'px',
                         }"
                         @click="selectPhoto(photo)">
                        <div class="photo-frame">
                            <img :src="photo.url" :alt="photo.title" loading="lazy" />
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Clone Container for Animation -->
        <div id="clone-container"></div>

        <!-- Detail Panel -->
        <div class="detail-panel" :class="{ 'active': expandedPhoto }">
            <div class="close-button" @click="closeDetailPanel">
                <i data-lucide="x" class="w-6 h-6"></i>
            </div>
            
            <!-- Target container for the image. We physically move the img node here. -->
            <div class="detail-photo" ref="detailPhotoContainer"></div>
            
            <div class="detail-content" v-if="selectedPhoto">
                <h1>{{ selectedPhoto.title }}</h1>
                
                <div class="meta-grid">
                    <div class="meta-item">
                        <div class="meta-label">Location</div>
                        <div class="meta-value">{{ selectedPhoto.location }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Date</div>
                        <div class="meta-value">{{ selectedPhoto.date }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Camera</div>
                        <div class="meta-value">{{ selectedPhoto.camera || 'iPhone 15 Pro' }}</div>
                    </div>
                    <div class="meta-item">
                        <div class="meta-label">Aperture</div>
                        <div class="meta-value">{{ selectedPhoto.aperture || 'f/1.8' }}</div>
                    </div>
                </div>

                <div class="diary-content">
                    {{ selectedPhoto.diary }}
                </div>

                <div class="mt-8 pt-8 border-t border-white/10">
                    <div class="flex gap-4">
                        <span v-for="tag in selectedPhoto.tags" :key="tag"
                              class="px-3 py-1 bg-white/5 rounded-full text-sm font-mono text-white/60">
                            #{{ tag }}
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas Background -->
        <canvas class="canvas-bg" ref="bgCanvas"></canvas>
    </div>

    <script>
        const { createApp, ref, onMounted, onUnmounted, nextTick } = Vue;

        createApp({
            setup() {
                // State
                const mode = ref('random');
                const photos = ref([]);
                const orbitals = ref([]);
                
                // Camera State (Used for Canvas Sync, DOM is driven by GSAP)
                const offset = ref({ x: 0, y: 0 }); 
                const scale = ref(1.0);
                
                // Interaction State
                const activePhoto = ref(null);
                const expandedPhoto = ref(null);
                const selectedPhoto = ref(null);
                const loading = ref(true);
                const dragInstance = ref(null);
                
                // Refs
                const galleryViewport = ref(null);
                const galleryMover = ref(null);
                const galleryScaler = ref(null);
                const bgCanvas = ref(null);
                const detailPhotoContainer = ref(null);
                
                // Config
                const center = ref({ x: 0, y: 0 }); 
                const orbitalConfig = [
                    { radius: 400, electronCount: 4, speed: 0.002 },
                    { radius: 600, electronCount: 5, speed: 0.0015 },
                    { radius: 800, electronCount: 6, speed: 0.001 },
                    { radius: 1000, electronCount: 7, speed: 0.0008 }
                ];

                const loadPhotos = async () => {
                    try {
                        const response = await fetch('https://raw.githubusercontent.com/gitmichaelqiu/gitmichaelqiu.github.io/refs/heads/main/photos.json');
                        const data = await response.json();
                        photos.value = data.photos;
                        initializeRandomPositions();
                        loading.value = false;
                    } catch (error) {
                        console.error('Error loading photos:', error);
                        loading.value = false;
                        if(photos.value.length === 0) {
                            photos.value = Array.from({length: 10}, (_, i) => ({
                                id: i,
                                url: `https://picsum.photos/seed/${i}/400/600`,
                                title: 'Sample Photo ' + i,
                                location: 'Unknown',
                                date: '2025',
                                diary: 'Sample description...',
                                tags: ['sample', 'art']
                            }));
                            initializeRandomPositions();
                        }
                    }
                };

                const initializeRandomPositions = () => {
                    center.value = { x: window.innerWidth * 1.5, y: window.innerHeight * 1.5 };
                    orbitals.value = orbitalConfig.map((config, index) => ({
                        ...config,
                        centerX: center.value.x + (Math.random() - 0.5) * 800,
                        centerY: center.value.y + (Math.random() - 0.5) * 800,
                        currentAngle: Math.random() * Math.PI * 2
                    }));

                    photos.value.forEach((photo, index) => {
                        const orbitalIndex = index % orbitalConfig.length;
                        const orbital = orbitals.value[orbitalIndex];
                        const electronIndex = Math.floor(index / orbitalConfig.length);
                        const totalInOrbital = Math.ceil(photos.value.length / orbitalConfig.length);
                        const angle = (2 * Math.PI / totalInOrbital) * electronIndex;
                        const jitter = 0.25;
                        const baseX = orbital.centerX + Math.cos(angle) * orbital.radius;
                        const baseY = orbital.centerY + Math.sin(angle) * orbital.radius;
                        
                        photo.position = {
                            x: baseX + (Math.random() - 0.5) * orbital.radius * jitter,
                            y: baseY + (Math.random() - 0.5) * orbital.radius * jitter,
                            orbital: orbitalIndex,
                            angle: angle,
                            baseRadius: orbital.radius,
                            baseX: orbital.centerX,
                            baseY: orbital.centerY
                        };
                    });
                };

                const updateElectronPositions = () => {
                    if (loading.value || activePhoto.value) return; 
                    
                    orbitals.value.forEach((orbital, orbitalIndex) => {
                        orbital.currentAngle += orbital.speed;
                        photos.value.forEach(photo => {
                            if (photo.position.orbital === orbitalIndex) {
                                const newAngle = photo.position.angle + orbital.currentAngle;
                                const waveFactor = 0.95 + Math.sin(Date.now() * 0.001 + photo.id) * 0.1;
                                photo.position.x = orbital.centerX + Math.cos(newAngle) * photo.position.baseRadius * waveFactor;
                                photo.position.y = orbital.centerY + Math.sin(newAngle) * photo.position.baseRadius * waveFactor;
                            }
                        });
                    });
                };

                // --- ZOOM LOGIC (Fixed Jiggle & Cursor Centering) ---
                const handleWheel = (e) => {
                    if (expandedPhoto.value) return; 
                    e.preventDefault();
                    
                    const zoomSensitivity = 0.001;
                    const delta = -e.deltaY * zoomSensitivity;
                    const oldScale = scale.value;
                    const newScale = Math.min(Math.max(0.1, oldScale + delta), 4.0);
                    
                    if (Math.abs(newScale - oldScale) < 0.0001) return;

                    // 1. Get current Draggable state (Source of Truth for X/Y)
                    const drag = Draggable.get(galleryMover.value);
                    if (!drag) return;
                    
                    const currentX = drag.x;
                    const currentY = drag.y;

                    // 2. Calculate Stable Point Math
                    const mouseX = e.clientX;
                    const mouseY = e.clientY;
                    const scaleRatio = newScale / oldScale;
                    
                    // New position = Mouse - (Mouse - OldPos) * ratio
                    const newX = mouseX - (mouseX - currentX) * scaleRatio;
                    const newY = mouseY - (mouseY - currentY) * scaleRatio;

                    // 3. Update State
                    scale.value = newScale;
                    offset.value.x = -newX; // Canvas uses inverse
                    offset.value.y = -newY;

                    // 4. Update DOM immediately (Bypass Vue binding)
                    gsap.set(galleryMover.value, { x: newX, y: newY });
                    gsap.set(galleryScaler.value, { scale: newScale });
                    
                    // 5. Sync Draggable so physics work on next drag
                    drag.x = newX;
                    drag.y = newY;
                    drag.update(); // Crucial: tells Draggable the transform changed
                };

                // --- ANIMATION LOGIC (FLIP + Aspect Ratio Morph) ---
                const selectPhoto = async (photo) => {
                    if (expandedPhoto.value === photo.id || activePhoto.value) return;
                    
                    activePhoto.value = photo.id;
                    selectedPhoto.value = photo;
                    
                    // Clear any existing content in detail panel
                    const targetContainer = detailPhotoContainer.value;
                    if (targetContainer) targetContainer.innerHTML = '';
                    
                    if(dragInstance.value) dragInstance.value.disable(); 

                    await nextTick();

                    const originalEl = document.getElementById(`photo-electron-${photo.id}`);
                    if (!originalEl) return;

                    // 1. Setup Clone
                    const startRect = originalEl.getBoundingClientRect();
                    const clone = document.createElement('div');
                    clone.id = 'active-clone';
                    clone.className = 'animation-clone';
                    
                    // Clone starts exactly over the original
                    gsap.set(clone, {
                        left: startRect.left,
                        top: startRect.top,
                        width: startRect.width,
                        height: startRect.height,
                        borderRadius: '12px'
                    });
                    
                    // Create IMG element (New Node)
                    const img = document.createElement('img');
                    img.src = photo.url;
                    img.className = 'detail-img';
                    clone.appendChild(img);
                    
                    document.getElementById('clone-container').appendChild(clone);

                    // 2. Calculate Final Target Dimensions (Fit natural ratio into container)
                    const contRect = targetContainer.getBoundingClientRect();
                    
                    // Determine natural ratio
                    let ratio = 2/3; // Default fallback
                    const sourceImg = originalEl.querySelector('img');
                    if (sourceImg && sourceImg.naturalWidth) {
                        ratio = sourceImg.naturalWidth / sourceImg.naturalHeight;
                    }

                    const contRatio = contRect.width / contRect.height;
                    
                    let targetW, targetH;
                    if (ratio > contRatio) {
                        targetW = contRect.width;
                        targetH = targetW / ratio;
                    } else {
                        targetH = contRect.height;
                        targetW = targetH * ratio;
                    }

                    // Center it
                    const targetLeft = contRect.left + (contRect.width - targetW) / 2;
                    const targetTop = contRect.top + (contRect.height - targetH) / 2;
                    
                    // 3. Animate Clone Wrapper
                    // Since 'detail-img' is object-fit: cover, and the wrapper matches the image ratio at the end,
                    // it will visually "un-crop" smoothly as the container changes shape.
                    gsap.to(clone, {
                        left: targetLeft,
                        top: targetTop,
                        width: targetW,
                        height: targetH,
                        borderRadius: 4, 
                        duration: 0.8,
                        ease: "power4.inOut",
                        onComplete: () => {
                            expandedPhoto.value = photo.id;
                            
                            // 4. Reparenting - Move the IMG node to the panel
                            // This preserves the loaded pixel data (No Flash)
                            if (targetContainer && img) {
                                // Important: Set size styles on the img before moving 
                                // to match the parent constraints immediately
                                img.style.width = '100%';
                                img.style.height = '100%';
                                targetContainer.appendChild(img);
                            }
                            
                            // Remove empty clone
                            clone.remove();
                        }
                    });

                    // 4. Push others away
                    photos.value.forEach(p => {
                        if (p.id !== photo.id) {
                            gsap.to(`#photo-electron-${p.id}`, { opacity: 0.1, duration: 0.5 });
                        }
                    });
                };

                const closeDetailPanel = () => {
                    const photo = selectedPhoto.value;
                    expandedPhoto.value = null;
                    
                    const img = detailPhotoContainer.value.querySelector('img');
                    const originalEl = document.getElementById(`photo-electron-${photo.id}`);

                    if (img && originalEl) {
                        // 1. Re-create Clone for return journey
                        const startRect = img.getBoundingClientRect();
                        
                        const clone = document.createElement('div');
                        clone.id = 'return-clone';
                        clone.className = 'animation-clone';
                        
                        // Start where the detail image is
                        gsap.set(clone, {
                            left: startRect.left,
                            top: startRect.top,
                            width: startRect.width,
                            height: startRect.height,
                            borderRadius: '4px',
                            zIndex: 9999
                        });
                        
                        clone.appendChild(img); // Move img back to clone
                        document.getElementById('clone-container').appendChild(clone);

                        // 2. Animate back to orbital position
                        const destRect = originalEl.getBoundingClientRect();

                        gsap.to(clone, {
                            left: destRect.left,
                            top: destRect.top,
                            width: destRect.width,
                            height: destRect.height,
                            borderRadius: '12px',
                            duration: 0.8,
                            ease: "power4.inOut",
                            onComplete: () => {
                                clone.remove();
                                activePhoto.value = null;
                                selectedPhoto.value = null;
                                if(dragInstance.value) dragInstance.value.enable();
                            }
                        });
                    } else {
                        // Fallback
                        activePhoto.value = null;
                        selectedPhoto.value = null;
                        if(dragInstance.value) dragInstance.value.enable();
                    }

                    // Restore others
                    photos.value.forEach(p => {
                        if (p.id !== photo.id) {
                            gsap.to(`#photo-electron-${p.id}`, { opacity: 1, duration: 0.5 });
                        }
                    });
                };

                const switchMode = (newMode) => {
                    mode.value = newMode;
                };

                const goBack = () => {
                    window.location.href = 'index.html';
                };

                // --- BACKGROUND CANVAS ---
                const initBackgroundCanvas = () => {
                    const canvas = bgCanvas.value;
                    if(!canvas) return;
                    const ctx = canvas.getContext('2d');
                    
                    const resizeCanvas = () => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                    
                    resizeCanvas();
                    window.addEventListener('resize', resizeCanvas);
                    
                    const drawField = () => {
                        if (loading.value) { requestAnimationFrame(drawField); return; }
                        
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        ctx.save();
                        // Apply Camera Transform
                        ctx.translate(-offset.value.x, -offset.value.y);
                        ctx.scale(scale.value, scale.value);
                        
                        ctx.strokeStyle = 'rgba(0, 47, 167, 0.1)';
                        ctx.lineWidth = 1 / scale.value;
                        orbitals.value.forEach(orbital => {
                            ctx.beginPath();
                            ctx.arc(orbital.centerX, orbital.centerY, orbital.radius, 0, Math.PI * 2);
                            ctx.stroke();
                        });

                        ctx.strokeStyle = 'rgba(0, 47, 167, 0.05)';
                        ctx.lineWidth = 0.5 / scale.value;
                        
                        if (scale.value > 0.2) {
                            for (let i = 0; i < photos.value.length; i++) {
                                for (let j = i + 1; j < photos.value.length; j++) {
                                    const p1 = photos.value[i];
                                    const p2 = photos.value[j];
                                    if (Math.abs(p1.position.orbital - p2.position.orbital) > 1) continue;
                                    const dx = p1.position.x - p2.position.x;
                                    const dy = p1.position.y - p2.position.y;
                                    if (dx*dx + dy*dy < 160000) {
                                        ctx.beginPath();
                                        ctx.moveTo(p1.position.x, p1.position.y);
                                        ctx.lineTo(p2.position.x, p2.position.y);
                                        ctx.stroke();
                                    }
                                }
                            }
                        }
                        ctx.restore();
                        requestAnimationFrame(drawField);
                    };
                    
                    drawField();
                    return () => window.removeEventListener('resize', resizeCanvas);
                };

                // --- DRAGGABLE ---
                const initDrag = () => {
                    const el = galleryMover.value;
                    // Initial centering
                    offset.value.x = window.innerWidth;
                    offset.value.y = window.innerHeight;
                    
                    // Initial Set
                    gsap.set(el, { x: -offset.value.x, y: -offset.value.y });

                    dragInstance.value = Draggable.create(el, {
                        type: "x,y",
                        inertia: true,
                        edgeResistance: 0.65,
                        onDrag: function() {
                            offset.value.x = -this.x;
                            offset.value.y = -this.y;
                        },
                        onThrowUpdate: function() {
                            offset.value.x = -this.x;
                            offset.value.y = -this.y;
                        }
                    })[0];
                };

                const animationLoop = () => {
                    updateElectronPositions();
                    requestAnimationFrame(animationLoop);
                };

                onMounted(async () => {
                    lucide.createIcons();
                    await loadPhotos();
                    await nextTick();
                    initDrag();
                    const cleanup = initBackgroundCanvas();
                    animationLoop();
                    
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && expandedPhoto.value) {
                            closeDetailPanel();
                        }
                    });
                    
                    return cleanup;
                });

                return {
                    mode, photos, orbitals, scale, activePhoto, expandedPhoto, selectedPhoto, loading,
                    galleryViewport, galleryMover, galleryScaler, bgCanvas, detailPhotoContainer,
                    selectPhoto, closeDetailPanel, switchMode, goBack, handleWheel
                };
            }
        }).mount('#app');
    </script>
</body>
</html>